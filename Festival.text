* Jak to funguje

Zpracování textu se skládá z následujících fází, definovaných v synthesis.scm:

(defUttType Text
  (Initialize utt)
  (Text utt)
  (Token_POS utt)
  (Token utt)
  (POS utt)
  (Phrasify utt)
  (Word utt)
  (Pauses utt)
  (Intonation utt)
  (PostLex utt)
  (Duration utt)
  (Int_Targets utt)
  (Wave_Synth utt)
  )

V¹e se toèí okolo tzv. utterance, které pøedstavuje jakousi jednotku, více èi
ménì anotovanou, kterou lze postupným doplòováním anotací (*features*) dostat
a¾ do stavu, kdy je schopna odeslání na zvukový výstup.  Ka¾dá z vý¹e uvedených
fází je volání funkce na utterance `utt'.

Chce-li si èlovìk vysyntetizovat text, vytvoøí pøíslu¹né utterance následujícím
zpùsobem:

  (Utterance Text "nìjaký text")

Funkce vrátí nezpracované utterance, které lze nechat plnì zanalyzovat voláním
funkce `utt.synth'.

Utterance se skládá z relations, jejich¾ jména lze zjistit pomocí

  (utt.relationnames utterance)

Obsah (seznam polo¾ek, items) ¾ádaného relation se vytáhne pomocí

  (utt.relation.items utterance 'relation-name)

Základními vlastnostmi polo¾ky jsou její jméno a rysy:

  (item.name item)

Mnohé polo¾ky se objevují na více místech, napøíklad konkrétní Word mù¾e mít
pøiøazeno Phrase, takové Phrase je pak dostupno jako rys Word.  Rysy polo¾ky
lze zjistit pomocí

  (item.features item)

Lze si vyzkou¹et:

  (mapcar item.features (utt.relation.items utterance 'Word))

Pro vypsání relace je pøehlednìj¹í výstup z

  (utt.relation.print utterance 'Word)

Lze té¾ pou¾ít

  (utt.relation_tree utt 'SylStructure)

Obèas nará¾íme na pojem globálního parametru.  Hodnotu globálního parametru lze
získat voláním

  (Parameter.get 'jméno-parametru)

** Initialize

Jen vytvoøí prázdné utterance.

** Text

Provede rozdìlení textu na tokens.  Funkce `Text' je napsána v C++, vyu¾ívá
v¹ak promìnné `token.*' definované v token.scm.

Definovaná interpunkèní znaménka jsou oddìlena od výsledných tokenù a jsou
dostupná jako jejich features.

** Token_POS

Provádí, je-li tøeba, kontextové oznaèkování tokenu pro rozli¹ení rùzného
významu shodných tokenù.  Viz dokumentace.

** Token

Pøevádí tokeny na slova.  Pøevod lze provést definicí funkce token_to_words.
Pøi konverzi tokenu je mo¾no se podívat na okolní tokeny, tak¾e je mo¾no
provádìt i sofistikovanìj¹í operace ne¾ pouhé mapování jediného tokenu na jedno
nebo více slov.

** POS (POS == Part of Speech)

Provádí tagování konkrétních slov dle jejich pozice v øeèi.  Nepovinná èást.
Parametrizovatelné pomocí nìkolika promìnných.  Pro èe¹tinu pou¾íváme zcela
vlastní metodu, která vyznaèuje interpunkci (v angliètinì se to v POS dìje
taky, ale nìjakým jiným zpùsobem a s jinými výsledky).

** Phrasify

Identifikace mezer (¾ádná, normální, dlouhá) mezi slovy.  Mezi vìt¹inu slov se
nevkládá ¾ádná mezera, vkládá se za interpunkci, nìkdy krátká (po èárce), nìkdy
dlouhá (konec vìty).  Tato funkce sama o sobì mezery nevkládá, to se dìje a¾ na
základì jí generovaných informací v Pauses.

Pou¾íváme jednodu¹¹í, nestatistickou, metodu `cart_tree', pøièem¾ zohledòujeme
v první øadì interpunkci.

** Word

Provádí pøevod slov na fonémy a slabiky v implicitním festivalovém formátu.
Definováno v lexicon.scm, není-li globálním parametrem Word_Method øeèeno
jinak, volá se C++ funkce Classic_Word.

Celý process je pomìrnì podrobnì popsán v dokumentaci, sekce Lexicons.
Definovaný postup pro èe¹tinu funguje zhruba následujícím zpùsobem:

- Výjimky jsou definovány pøes lex.add.entry.

- Jinak se uplatòuje funkce czech-lts.

- czech-lts nejprve pøevede text na fonémy a pak volá obvyklou festivalovou
  funkci lex.syllabify.phstress pro jejich sestavení do slabik.  Slabiky jsou
  identifikovány v C++ funkci `syl_breakable' podle samohlásek (které jsou
  definovány ve phone set).

** Pauses

Vkládá mezery.  Pro tuto akci se pou¾ívá funkce definovaná globálním parametrem
Pause_Method.  Implicitní je funkce Classic_Pauses, definovaná v pauses.scm.
Funkce dìlá v zásadì to, ¾e vlo¾í poèáteèní mezeru (lze odru¹it pøedefinováním
funkce insert_initial_space), a pak vlo¾í mezery dle informací vytvoøených ve
fázi Phrasify.  Navíc vyøadí z utterance slova oznaèená jako interpunkce.

** Intonation

Generuje akcenty pro intonaci (první fáze zpracování intonace), ale nevytváøí
je¹tì intonaci samotnou (druhá fáze zpracování intonace), to dìlá a¾
Int_Targets.  Pou¾ívá se funkce definovaná globálním parametrem Int_Method.  Je
to popsáno v dokumentaci, sekce Intonation.

** PostLex

V této fázi lze aplikovat jakékoliv dodateèné transformace nad utterance,
zaøazené v seznamu postlex_rules_hooks.

** Duration

Urèení délky trvání jednotlivých segmentù syntetizovaného textu.  Viz manuál,
sekce Duration.

** Int_Targets

Sestaví finální intonaci.  Viz manuál.

** Wave_Synth

Samotné sestavení zvuku na základì ji¾ v¹ech dostupných anotací.  Funkce, která
se pro syntézu zavolá, je definována globálním parametrem `Synth_Method'.
Funkce Wave_Synth je ve Scheme a nachází se v synthesis.scm.


* Praktické poznámky

Docstringy umí vypsat funkce `doc'.

Readline umí doplòovat jména funkcí, dost èasto u¾iteèné.


* Pøíklady

** Angliètina

Analýza textu "Hello, world! How are you?":

festival> (set! utt (Utterance Text "Hello, world!  How are you?"))
#<Utterance 0x40757ec8>
